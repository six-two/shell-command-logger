#!/usr/bin/env python3
# Call me like this: "scl-alias --print bash | source"
# This does not seem to work in zsh. Workaround: "scl-alias -p zsh > /tmp/zsh && source /tmp/zsh"
import argparse
import os
import sys
# import the code from this package
from shell_command_logger.alias import print_text_to_source, load_alias_file, save_alias_file, CONFIG_FILE


def main():
    ap = argparse.ArgumentParser()
    mutex = ap.add_mutually_exclusive_group()
    mutex.add_argument("-p", "--print", metavar=("shell"), choices=["bash", "fish", "zsh"], help="print the commands to create the aliases for the given shell. This can be directly piped into `source`")
    mutex.add_argument("-l", "--list", action="store_true", help="list all the programs, that the aliases should be created for")
    mutex.add_argument("-s", "--set", nargs="*", help="overwrites the alias list with the given values. This deletes all old entries")
    mutex.add_argument("-a", "--add", nargs="+", help="add the given programs to the alias list")
    mutex.add_argument("-d", "--delete", nargs="+", help="delete the given programs from the alias list")
    mutex.add_argument("--reset", action="store_true", help="reset the alias list back to the default value")
    args = ap.parse_args()

    if args.print:
        shell = args.print
        print_text_to_source(shell)
    elif args.list:
        for program in load_alias_file():
            print(program)
    elif args.set is not None:
        save_alias_file(args.set)
    elif args.add:
        programs = load_alias_file()
        programs += args.add
        save_alias_file(programs)
    elif args.delete:
        programs = load_alias_file()
        programs = [x for x in programs if x not in args.delete]
        save_alias_file(programs)
    elif args.reset:
        os.remove(CONFIG_FILE)
    else:
        print("No action specified. See --help for the available options")
        sys.exit(1)

if __name__ == "__main__":
    main()

